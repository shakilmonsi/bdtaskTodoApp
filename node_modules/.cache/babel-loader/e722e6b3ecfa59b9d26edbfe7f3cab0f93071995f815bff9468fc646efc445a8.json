{"ast":null,"code":"// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in window;\nfunction noop() {\n  return void 0;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (typeof fetchStatus !== \"undefined\" && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    status,\n    predicate,\n    mutationKey\n  } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (typeof ctor === \"undefined\") {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nexport { addToEnd, addToStart, functionalUpdate, hashKey, hashQueryKeyByOptions, isPlainArray, isPlainObject, isServer, isValidTimeout, keepPreviousData, matchMutation, matchQuery, noop, partialMatchKey, replaceData, replaceEqualDeep, shallowEqualObjects, sleep, timeUntilStale };","map":{"version":3,"mappings":"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","names":["isServer","window","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","matchQuery","filters","query","type","exact","fetchStatus","predicate","queryKey","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","status","mutationKey","hashKey","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","some","replaceEqualDeep","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","sleep","ms","Promise","resolve","setTimeout","replaceData","prevData","data","structuralSharing","keepPreviousData","previousData","addToEnd","items","item","newItems","slice","addToStart"],"sources":["C:\\todoAppMain\\node_modules\\@tanstack\\query-core\\src\\utils.ts"],"sourcesContent":["import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options;\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n        const oldPages = context.state.data?.pages || [];\n        const oldPageParams = context.state.data?.pageParams || [];\n        const empty = {\n          pages: [],\n          pageParams: []\n        };\n        let cancelled = false;\n        const addSignalProperty = object => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = context.options.queryFn || (() => Promise.reject(new Error(`Missing queryFn: '${context.options.queryHash}'`)));\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(queryFnContext);\n          const {\n            maxPages\n          } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        let result;\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          result = await fetchPage(empty, oldPageParams[0] ?? options.initialPageParam);\n          const remainingPages = pages ?? oldPages.length;\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result);\n            result = await fetchPage(result, param);\n          }\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(fetchFn, {\n            queryKey: context.queryKey,\n            meta: context.options.meta,\n            signal: context.signal\n          }, query);\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, _ref) {\n  let {\n    pages,\n    pageParams\n  } = _ref;\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);\n}\nfunction getPreviousPageParam(options, _ref2) {\n  let {\n    pages,\n    pageParams\n  } = _ref2;\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"mappings":"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","names":["addToEnd","addToStart","infiniteQueryBehavior","pages","onFetch","context","query","fetchFn","options","direction","fetchOptions","meta","fetchMore","oldPages","state","data","oldPageParams","pageParams","empty","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","Promise","reject","Error","queryHash","fetchPage","param","previous","length","resolve","queryFnContext","queryKey","pageParam","page","maxPages","addTo","result","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","initialPageParam","remainingPages","i","persister","lastIndex","hasNextPage","hasPreviousPage"],"sources":["C:\\todoAppMain\\node_modules\\@tanstack\\query-core\\src\\infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options as InfiniteQueryPageParamsOptions<TData>\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        const empty = { pages: [], pageParams: [] }\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              new Error(`Missing queryFn: '${context.options.queryHash}'`),\n            ))\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: Omit<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        let result: InfiniteData<unknown>\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          // Fetch first page\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam,\n          )\n\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch remaining pages\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result)\n            result = await fetchPage(result, param)\n          }\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams,\n  )\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams,\n  )\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}